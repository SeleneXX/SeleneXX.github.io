这道题如果不考虑超长整数其实非常好解决：
````python
def print(n):
    return range(0, 10**n - 1)
````
但是如果考虑了超长整数，虽然python并不会溢出，但是其他语言就会出现问题。保存长度无限的整数，只能用字符串。所以，可以用字符串保存需要输出的整数。先对字符串进行初始化：
````
num = [0] * n
````
这里的意思是总共有n位所以初始化一个长度位n的列表。然后，从0开始，递归调用函数，使数组的每一位都填上0到9，如果填到了最后一位，此时就可以把这个列表join成字符串并输出。
完整代码如下：
````python
class Solution:
    def printNumbers(self, n: int) -> [int]:
        def dfs(x):
            if x == n:
                s = ''.join(num[self.start:])
                if s != '0': res.append(int(s))   #剔除00000000的列表
                if n - self.start == self.nine: 
                    self.start -= 1   #一旦发现当前长度的列表中全是9，代表输出下一位数字，需要进一位了。
                return
            for i in range(10):
                if i == 9: self.nine += 1
                num[x] = str(i)     
                dfs(x + 1)      #递归调用函数，
            self.nine -= 1      #每运行完一整个循环，也就是一次0到9，需要回溯到上一层，所以需要把刚刚+1的nine数组复原
        
        num, res = ['0'] * n, []      #初始化num用于保存长整数，res用于表示输出的字符串。
        self.nine = 0
        self.start = n - 1      #初始时只输出最后一位，每多一位start前移一位，也就是start - 1
        dfs(0)
        return res
````
当然，这种方法，会出现类似以下的情况。例如：输出1的时候，会变成00000001，前面多了很多位不需要的0。为了解决这一情况，代码中加入了self.start和self.nine两个变量，分别用于记录当前输出的数组应该从哪一位开始输出，和数组中9的个数。
众所周知，9999下一个就变成10000，所以在输出的时候，一旦数组的长度减去数组最开始0的位数start，如果等于9的个数，就代表需要进一位，此时，只需要对start - 1，就可以方便的进位。
