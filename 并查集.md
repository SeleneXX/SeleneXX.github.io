并查集可用于图论，可以求连通分量，判断连通信等等，效率极高。首先初始化一个长度等于图结点数的数组或者字典。以数组为例：
````python
array = [n for n in range(len(graph))]
````
数组的每个位置也就是array[i]初始存放本数，代表初始其父节点为自己。每连通两个点，则代表将两个点的父亲结点连接在一起。

find方法用于寻找结点的根结点，通过递归，不断向上寻找，直到找到根结点：
````python
def find(x):
    if array[x] != x:
        array[x] = find(array[x]) #递归找到根结点
    return array[x]
````
union方法用于连接两个顶点：
````python
def union(x, y):
    root_x = find(x)
    root_y = find(y) #找到两个结点的根结点
    array[root_x] = root_y #然后将结点x的根节点连接到结点y的根节点，于是x，y连通
````
特别的，当结点的表示为二维数组时，如平面坐标系，连接两个同行或者同列的结点有一个高效且巧妙的方法：将横纵坐标当成两个结点，存放入同一个数组，为了区分，令横坐标为负数，从-1开始，也就是x = -x - 1。在连接各个结点前，先把每个结点的x与y坐标相连，这样一来，同行或者同列的结点就自然相互连接。例如（1，1）与（1，4），先将-1 - 1（x取负数与y区分） 与 1相连，再将 - 1 - 1的根节点与4相连，也就是1与4相连，这两个点就自然而然的连接在一起了,效率极高，比用字典连接判断同行同列省去了很多的时间，时间复杂度仅为O(n)因为只需要遍历依次图中结点即可。这就是leetcode中的那道棋盘中依次拿走石头的题([leetcode947](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/))，较为高效巧妙的一种解法。
````python
for x, y in stones:
    self.union(-x - 1, y)  # 对横坐标取反，与纵坐标做区分
````
