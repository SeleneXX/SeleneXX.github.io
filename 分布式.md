# 分布式

## 1. 什么是分布式系统

- 多个cpu一起工作
- 一群独立工作的计算机，但是对于用户而言就像单一的系统

#### 优势：

- 沟通和资源共享
- 高性价比
- 可靠可扩展
- 有很大的潜力

## 2. 集群服务器调度

#### 大型web服务器集群结构

- 一个节点用于负载均衡/调度
- 其他节点干活

请求抵达负载均衡节点后，调度节点将请求分配给一个worker

如何选择要分配的worker：

- 负载最少：每次选择负载最少的worker
- 循环分配：依次给每个worker分配
  - 当服务器不同时，使用加权循环分配
- 随机分配（完全随机哈希）
  - 使用一致性哈希，如果某个机器负载已满，自动后移
  

基于session的负载均衡和基于request的负载均衡：

- 基于session：一个session中可能有数个请求（购物车结算），将这一个session中的数个请求交给一个服务器
- 基于request

## 3. 云计算

#### IaaS基础设施服务

- 租借服务器和存储空间
- 提供最高等级的灵活性和对 IT 资源的管理控制

#### PaaS平台即服务

- 租借程序和平台
- 消除了组织对底层基础设施（一般是硬件和操作系统）的管理需要

#### SaaS软件即服务

- 租借完善的产品

## 4. 时钟

### 集中式时间同步算法

#### Cristian算法

与一个带有utc接收器的服务器同步时间

- 每隔一定时间向时间服务器发起同步请求
- 收到服务器发来的响应，根据请求响应间隔的的时间，除以2得到一次通信的大致时长，将自己的时钟设置为服务器响应的时间加上通信消耗的时间。

#### Berkeley算法

没有utc服务器。使用一个计算机作为主节点。

- 主节点定期发起投票，获得从节点的时间
- 获取平均时间并且返回给每个从节点的时间与平均时间的差值
- 通信消耗的时间与克里斯蒂安相同

### 逻辑时钟

#### 事件排序

定义在系统中发生的所有事件的顺序

定义事件时间：

- 如果事件A比事件B早执行（A-->B），则C(A) < C(B)
- 如果A，B并发，则C(A) < 或 = 或 >C(B)

#### 解决方式：Lamport Clock

- 每个处理器维护一个逻辑时钟`LCi`
- 每当一个事件在本机i发生，则`LCi += 1`
- 当i向j发送消息，带上`LCi`
- 当j收到i的消息，如果`LCj<LCi`，则`LCj=LCi + 1`

Lamport Clock只能保证当a在b之前发生时，C(A) < C(B)。而如果AB并发，则C(A)，C(B)的关系并不能得到保证。

Lamport 逻辑时钟算法中每个进程只拥有自己的本地时间，没有其他进程的时间，导致无法描述事件的因果关系。

#### 解决方式： Vector Clock

- 每个节点i维护了一个向量Vi
  - `Vi[i]`：发生在节点i上的事件数目
  - `Vi[j]`：i节点所知道的发生在节点j的事件数目
- 更新时钟：
  - 每发生一个本地事件，`Vi[i] += 1`
  - 发送消息时，带上整个向量Vi
  - 每收到一条消息，`Vj[k]=max(Vj[k], Vi[k])`
    - 发送者告诉接收者他知道有多少事件发生在另一个节点k
    - 同时`Vj[k] += 1`

**基于向量时钟我们可以获得任意两个事件的顺序关系，结果要么是有因果关系（先后顺序），要么是没有因果关系（同时发生）。**

**假设有事件 a、b 分别在节点 P、Q 上发生，向量时钟分别为 Ta、Tb，如果 Tb[Q] > Ta[Q] 并且 Tb[P] >= Ta[P]，则a发生于b之前，记作 a -> b，此时说明事件 a、b 有因果关系； 反之，如果 Tb[Q] > Ta[Q] 并且 Tb[P] < Ta[P]，则认为a、b同时发生，记作 a <-> b。**

## 5. 选举算法

#### Bully election

任意节点都有一个独立的ID，每个节点知道除了自己以外所有节点的ID和地址，选择最高的ID作为新的master

过程：

- P向所有比自己ID大的节点发送选举请求
- 收到请求的节点回复P
- 收到请求的节点重复这一过程
- 如果一个节点没有收到回复，则说明他是最大的，向所有节点广播自己成为了master

复杂度O(n^2)

#### Ring-based election

每个节点都有独立的ID并且被放置在一个逻辑环上。每个节点知道左右相邻节点的地址。选择最高的ID作为master

## 6. 分布式锁

#### 互斥锁（中心化）

假设每个节点都被编号，并且有一个节点被选为了主节点。

每个从节点执行关键操作前，都必须向主节点申请。

从节点流程：

- 申请锁
- 等待响应
- 拿到锁
- 执行操作
- 释放锁

主节点流程：

- 申请锁，查看申请队列是否为空并且锁没有被占用，则赋予权限，否则，将申请加入队列
- 释放锁，从排队队列中取出第一个节点，并将锁赋予给这个节点

缺点：

- 从节点无法得知主节点是否挂了，因为收不到回复可能是因为锁被占用，也有可能是主节点挂了
- 大型分布式系统中，有性能瓶颈

解决方式：

#### 分散算法

使用投票，假设有n个副本，每个副本都有一个管理节点

申请锁时，必须有超过半数的管理节点同意

- 没有IO阻塞，因为只需要回复同意或者不同意

管理节点挂了，重新投票

## 7. 容错

#### 拜占庭将军问题

需要有2k+1个节点去查出k个错误

需要有2k+1个好的节点，总共3k + 1个节点，达成一致

#### 节点复制

- 分发到来的请求给不同的复制节点
  - 如果一个复制节点挂了，由其他的节点接手其工作
  - 适合作为节点挂掉的场景
- 将请求发给所有的复制节点
  - 所有的复制节点投票并选出票数最多的结果
  - 适合作为有复制节点产生错误的场景

#### Quorum 机制

在 N 个副本中，一次更新成功的如果有 W 个，那么我在读取数据时是要从大于 N－W 个副本中读取，这样才能至少读到一个更新的数据了。

#### Paxos算法

将角色分为proposer，acceptor，learner。

Proposer：

- 提出提案（操作）
- 可以有多个

Acceptor：

- 接受者可以对提议者提出的提议进行投票表决，接受者之间是完全独立的。
- 提议有超过半数的接受者投票批准即被选中。

Learner：

- 不参与选举，而是学习被批准的 value
- 参考了Quorum议会机制，某个value需要获得超过半数的Acceptor 批准，Learner需要至少读取 N/2+1个Accpetor，最多读取 N个Acceptor的结果后，才能学习到一个通过的value。

算法阶段：

- prepare阶段：

  - Proposer生成全局唯一且递增的提案编号N，向所有Acceptor发送Prepare请求

  - Acceptor收到Prepare请求后，有两种情况：

    - 如果Acceptor首次接收Prepare请求, 设置MaxN=N， 同时响应ok

    - 如果Acceptor不是首次接收Prepare请求，则：

      - 若请求过来的提案编号N小于等于上次持久化的提案编号ResN，则不响应或者响应error。

      - 若请求过来的提案编号N大于上次持久化的提案编号ResN, 则更新MaxN=N，同时给出响应。响应的结果有两种：
        -  如果这个Acceptor此前没有接受过提案，只返回ok，并承诺不再回复小于N的提案。
        - 如果这个Acceptor此前接收过提案，则返回ok和上次接受的提案编号AcceptN, 接收的提案AcceptV。
  
- 批准阶段：

  为了方便描述，我们把 Phase 2 选举阶段继续拆分为 P2a、P2b 和 P2c。

  P2a：Proposer接收Accept消息，发送Accept

  经过一段时间后，Proposer 收集到一些Prepare阶段的回复，有下列几种情况：

  - 若回复数量 > 一半的 Acceptor 数量，且所有回复的 value 都为空时，则 Porposer 发出 accept 请求，并带上自己指定的提案value。
  - 若回复数量 > 一半的 Acceptor 数量，且有的回复 value 不为空时，则 Porposer 发出 accept 请求，并挑选出回复中提案号最大的提案，取出提案的value作为自己的提案内容。
  - 若回复数量 <= 一半的 Acceptor 数量时，则重新尝试更新生成更大的提案号N，再转到准备阶段执行。

  P2b：Acceptor 应答 Accept
  
  Accpetor 收到 Accpet 请求后，判断：
  
  - 若收到的提案号N >= MaxN（一般情况下是等于），则回复提交成功，并持久化N和value，接受提案；
  - 若收到的 N < MaxN，则不回复或者回复提交失败，不接受提案。
  
  P2c: Proposer 统计投票
  
  经过一段时间后，Proposer 会收集到一些 Accept 回复提交成功的情况，比如：
  
  - 当回复数量 > 一半的 Acceptor 数量时，则表示提交 value 成功，此时可以发一个广播给所有的 Proposer、Learner，通知它们已提交的 value；
  - 当回复数量 <= 一半的 Acceptor 数量时，则尝试更新生成更大的提案号，转到准备阶段执行。
  - 当收到一条提交失败的回复时，则尝试更新生成更大的提案号，也会转到准备阶段执行。
  
- 学习阶段
  
  Proposer收到多数Acceptor的Accept后，决议形成，将形成的决议发送给所有Learner，Learner进行学习。