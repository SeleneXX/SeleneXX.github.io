输入一个二进制数，统计其中1的个数。
这个如果用一般的方法非常简单，只需要不停的模2````count = count + 1 if n % 2 == 1 else count````，再进行向右移位````n >>= 1````即可。
查看了评论区，有一种极其巧妙地算法。
假设把2进制数当成n位独立的数字，为了求其中1的个数，就是求这n位数字的和。例如以下这个二进制数（以8bit演示）：
0   1   0   1   1   0   1   0  
 \ /     \ /     \ /     \ /
  1       1       1       1
   \     /         \     /
      2               2
       \             /
              4
为了实现这种效果，有什么快捷的办法呢，就是相邻两位相加，然后相邻四位相加。。。以此类推。相邻两位相加，等于先取奇数位，也就是第1，3，5，7位，再取偶数位，然后相加。所以，只需要先把原数对0b01010101按位取与得到01010000，就可以得到只有奇数位的二进制数，然后右移一位，再取与就得到了偶数位00000101，然后和前面得到的奇数位相加。即可得到位数减半的数。也就是01010101。
然后，再对得到的01010101，对0b00110011按位取与，然后再右移两位，再按位取与，再相加，得到00100010，最后再按4位，取与，得到0100，也就是答案，4.
````python
class Solution:
    def hammingWeight(self, num: int) -> int:
        num = (num & 0x55555555) + ((num>>1) & (0x55555555))
        num = (num & 0x33333333) + ((num>>2) & (0x33333333))
        num = (num & 0x0f0f0f0f) + ((num>>4) & (0x0f0f0f0f))
        num = (num & 0x00ff00ff) + ((num>>8) & (0x00ff00ff))
        num = (num & 0x0000ffff) + ((num>>16) & (0x0000ffff))
        return num
````
