# 计算机网络面试

## 1. 什么构成了计算机网络

- 节点
  - 主机及程序
  - 路由器（网络层），交换机（链路层）等网络设备
- 边
  - 接入网链路：主机连接到互联网的链路
  - 主干网链路：路由器直接的链路
- 协议
  - tcp
  - udp
  - http
  - 等

## 2. 数据通信，报文交换的方式

- 住宅接入modem（猫），使用电话线路
- dsl（电话线路，支持边打电话边上网）
- 线缆网络（借助有线电视的线）

## 3. 五层模型

- 应用层：为应用进程提供网络服务。http，smtp，ftp
- 传输层：将网络层端到端的通信细化到进程到进程，并且保证了可靠通信。tcp，udp
- 网络层：为数据报文选择路由的端到端传输，不可靠。IP，路由协议
- 链路层：相邻网络节点之间的数据传输，基于物理层。Ethernet
- 物理层：在线路上传送bit

## 4. 应用层

### HTTP

- 工作在80端口，使用tcp进行数据传输。是无状态的短链接。
- 协议版本：
  - HTTP1.0：非持久连接，进行完一次通信就断开TCP连接。
  - HTTP1.1：持久连接。只要两端都没有提出断开连接，持久保持TCP连接。
  - HTTP2.0：
    - 二进制分帧：所有帧都采用二进制编码
    - 多路复用：允许同时通过单一的HTTP连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP2.0不再依赖多个TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（**每个域名一个连接**）即可。 
    - 请求优先级：HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序
    - header压缩
    - 服务端推送
- 持久连接：
  - http1.0 + keep alive：在客户端请求报文头部加上connection：keep alive，服务器如果愿意持久开放连接，则在回复报文中添加相同的首部，否则客户端会默认服务器不支持keep alive，请求关闭连接。
  
  - Http1.1 + persistent connection：http1.1默认持久连接，如果客户端需要关闭，则在请求头加上connection：close请求服务端关闭
  
- 持久连接方式：
  - 流水线：多个请求连续发出，不需要等待请求响应，http1.1默认使用这种方式
  
  - 非流水线：排队收发请求，等前一个请求收发完毕，才能开始发送下一个请求
  
- 请求报文：
  - 请求方法（POST，GET）+ URL + 协议版本（HTTP1.0，1.1）
  - 请求头
  - 请求体
- 响应报文：
  - 协议版本 + 状态码 + 状态码描述
  - 响应头
  - 响应体
- 状态码：
  - 1xx：请求已接受，需要请求者继续处理
  - 2xx：请求成功
    - 204 No content：请求成功，不需要返回任何实体内容

  - 3xx：重定向
  - 4xx：请求错误
    - 404 Not found：请求失败，请求的资源并未在服务器发现

  - 5xx：服务器错误
    - 502 Bad gateway：作为网关或代理服务器时，向上游服务器请求收到无效的响应

- 使用cookie+session可以使服务器识别出交互的浏览器。
  - HTTP响应和请求的报文中有cookie的首部行
  - 用户浏览器中存有对应网站的cookie和session
  - web服务器有后端数据库存储对应用户的cookie
- web缓存，通常由ISP安装。
- 浏览器和web缓存的交互
  - 浏览器访问web缓存服务器
  - web缓存没有，则主动请求目标服务器获取数据
  - web缓存下载数据并返回给浏览器
- 缓存一致性：web缓存数据经历一段时间后，会主动找服务器更新数据
- SSL是加密传输。HTTPS = HTTP + SSL。SSL工作在443端口

### FTP

文件传输协议，工作在21端口，基于tcp

### EMAIL

POP3，SMTP，IMAP

电子邮件有三个主要组成部分

- 客户端代理
- 邮件服务器
- SMTP简单邮件传输协议

a用qq邮箱给b的火狐邮箱发送邮件：

- a将邮件通过SMTP传输至qq邮箱服务器
- qq邮箱服务器将邮件通过SMTP传输到火狐邮箱服务器
- b上线可通过http请求，拉去最新的未读邮件

### DNS

- 根域名服务器
- 顶级域名服务器
- 权威域名服务器
- 本地域名服务器

解析流程：

- 查询浏览器缓存

- 查询本地host文件
- 查询本地DNS服务器的缓存
- 查询根DNS服务器
- 查询顶级DNS服务器
- 查询权威DNS服务器
- 本地DNS缓存查询的结果并返回给客户端，客户端缓存到本地DNS缓存

### Socket编程

通过socket 的接口，来控制协议找工作，从而实现网络通信，达到跨主机通信。

服务端流程：

- 服务器创建socket（TCP）

  ````python
  server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  ````

- 把socket绑定到本地地址和端口(bind)

  ````python
  # address = (IP, port)
  server.bind(address)
  ````

- 设置为监听模式(listen)，准备接受请求

  ````python
  server.listen(10000)
  ````

- 收到请求，建立连接(accept)

  ````python
  conn, _ = server.accept()
  ````

- 通信

  ````python
  request = conn.recv(1024)
  conn.send('message'.encode('utf-8'))
  ````

- 关闭连接，关闭socket

  ````python
  conn.close()
  server.close
  ````

客户端流程：

- 创建客户端socket

  ````python
  client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  ````

- 向服务端请求连接(connect)

  ````python
  client.connect((trader_addr, int(trader_port)))
  ````

- 通信

  ````python
  client.send(data.encode('utf-8'))
  ````

- 关闭连接

  ````python
  client.close()
  ````

## 5. 传输层

### TCP

#### 报文结构

| 前16位                                   | 后16位         |
| ---------------------------------------- | -------------- |
| 16位源端口号                             | 16位目的端口号 |
| 32位序号                                 |                |
| 32位确认序号                             |                |
| 4位首部长度+保留6位+标识符（SYN，ACK...) | 16位窗口大小   |
| 16位检验和                               | 16位紧急指针   |
| 选项                                     |                |
| 数据                                     |                |

- SYN：连接请求/接受 报文段
- seq：发送的第一个字节的序号
- ACK：确认报文段
- ack：确认号

#### 流量控制：

如果接收方接受速率不足，发送方就应该减缓发送的速率，避免接收方溢出。发送速率通过控制滑动窗口大小来控制。

#### 拥塞控制：

中途网络带宽不够，网络堵塞。通过丢包率感知。

TCP的连接速率是一个慢启动的过程：

- 一开始滑动窗口为1
- 每次收到ACK（回应）都会成倍的增加滑动窗口大小
- 每一次快速重试会将窗口大小降为一半
- 每次超时重传都会重置窗口为1

#### 三次握手：

- 第一次握手：客户端向服务端发送SYN=1报文，并指明客户端的初始化序列号ISN(x)，seq=x。此时客户端处于SYN_Send状态。
- 第二次握手：服务端收到客户端的SYN报文，会发送一个SYN=1作为应答，并指定自己的初始化序列号ISN(y)，seq=y，同时把客户端初始化序列号ISN(x)+1作为ack的值，ack=x+1，表示已经收到了服务端发来的SYN报文，希望收到的下一个数据的第一个字节的序号是x+1，此时服务器处于SYN_REVD的状态。
- 第三次握手：客户端收到服务器端响应的SYN报文之后，会发送一个ACK报文，也是一样把服务器的初始化序列号ISN(y)+1作为ack值，ack=y+1，表示已经收到了服务端发来的SYN报文，希望收到下一个数据的第一个字节的序号是y+1，并指明此时客户端的序列号是seq=x+1，此时客户端处于established状态。服务器收到ACK报文后也处于establish状态。

##### 三次握手的原因：

双方都要发出连接请求，交换自己的序列seq，并且确认对方可以正常的接受做出应答。本来需要往返四次，但是服务器这边将应答和请求合并了。

##### 两次握手不行：

两次握手相当于省略了第三次应答，服务器没法确认对方收到了自己的序列号。本来服务器在接收到对方第一次请求的时候进入的是半开状态，还没建立连接。两次握手意味着接收到对方请求后，服务器就直接进入了连接状态，能直接发送数据。这时候对方没接收到第二次的应答，没协商好seq序号就发送消息，会产生错乱。

##### 第三次握手丢失：

服务器在发出第二次握手后，会进入半开 SYN_REVD 的状态。等待第三次握手，如果第三次握手没有达到，会触发超时重传。例如间隔时间为 1s，2s，4s，8s

##### SYN洪泛攻击：

Attacker伪造很多ip向server发送SYN包，server回复确认包时，由于源地址不存在，因此server不断重发直至超时，导致正常的SYN请求因队列满而被丢弃，引发网络拥塞甚至瘫痪。

在服务器ack的时候，生成一个cookie，不用半开端口，等待合法客户带着cookie的第三次握手后，身份验证通过直接全开端口。

#### 四次挥手

客户端请求结束，服务端响应请求

服务端决定结束，客户端响应结束

挥手不能缩减为3次，因为服务端收到结束请求时可能还有没有完成的传输任务。

### UDP校验

UDP数据报中，有一个校验和字段用于数据报完整性检查。在计算检验和时，要在UDP用户数据报之前增加12个字节的**伪首部**。并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。

UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是**把首部和数据部分一起检验**。

发送方：先把全0放入检验和字段。再把伪首部以及UDP用户数据报看成是由许多**16位的串**连接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全0字节(但此字节不发送)。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入检验和字段后，就发送这样的UDP用户数据报。

接收方：把收到的UDP用户数据报连同伪首部(以及可能的填充全0字节)一起，按二进制反码求这些16位串的和。当无差错时其结果应该为全1。否则就表明有差错出现，接收方就应该丢弃这个UDP用户数据报(也可以上交给应用层，但附上差错警告)。

### TCP VS UDP

| TCP                  | UDP            |
| -------------------- | -------------- |
| 面向连接             | 无连接         |
| 有序                 | 无序           |
| 速度慢               | 速度快         |
| 重量级               | 轻量级         |
| 适合对可靠性要求高的 | 适合聊天，直播 |

UDP实现可靠传输：

- 添加seq/ack机制
- 双方设置缓冲区
- 增加超时重传机制

## 6. 网络层

### IP数据报

![image-20230406005348031](C:\Users\Selene\AppData\Roaming\Typora\typora-user-images\image-20230406005348031.png)

所有的TCP和UDP等传输层数据报都基于IP数据报。IP数据报可以分片发送。比如可以将一整个UDP数据报分成4个数据报片发送。为了保证数据报片可以合成一整个数据报，在ip数据报中加入了标识符，只有标识符相同的数据报片可以合成完整的IP数据报。

### ICMP

## 7. 浏览器url按下回车发生了什么

- DNS解析，查找到url对应的IP地址
- IP寻址，3次握手建立TCP
- 生成HTTP报文，发送HTTP请求，等待服务器响应
- 服务器处理请求，返回客户端
- 根据HTTP是否开启长连接，进行TCP挥手
- 渲染页面