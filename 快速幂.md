求幂时，如果指数特别大，传统递归相乘会导致效率极低。快速幂就是一种可以极大的提高运算效率的方法。
快速幂采用了二进制的思想。假设指数为11，那么11转化为二进制就是0b1011。所以，原运算就变成了：x ** (0b1011)，而二进制是能拆分的，所以原式化为x ** (1*2**0 + 1*2**1 + 0*2**2 + 1*2**3) = x**(1*2**0) * x**(1*2**1) * x**(1*2**3) = x**1 * x**2 * x**8。
成功的把x**11 转化为了x * x**2 * x ** 8.
为了实现这一算法，只需要使用一个循环，每循环一次，n右移一位，也就是除以2，然后看末位是不是1，使用&操作可以快速完成这一步。
代码如下：
````python
def myPow(self, x: float, n: int) -> float:
      if n == 0:
          return 1
      res = 1   #初始化，指数分解的第一项为1
      if n < 0:
          x = 1/x
          n = -n
      while n > 0:
          if n & 1 == 1:    #如果末位是1，则与当前分解出来的指数项相乘
              res *= x
          x *= x    #后移一位
          n >>= 1
      return res
````
