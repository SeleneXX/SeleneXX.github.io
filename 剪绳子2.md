给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

[原题](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof)

和上一题几乎一样，但是多了个取模条件。直接搬上一题的代码对答案取模结果发现不行。后来才知道，每当乘积大于一次1e9 + 7，就要取一次模。所以这就导致了上一次的方法不好使。
换了个思路，使用while循环，每次对绳子减3厘米，结果*3并对1e9 + 7取模，直到绳子小于等于四厘米，所得的结果就是3 ** n *最后绳子所剩的长度。
````python
class Solution:
    def cuttingRope(self, n: int) -> int:
        if n <= 3:
            return n - 1
        else:
            res = 1
            while n > 4:
                res = (res * 3) % (1e9 + 7)
                n -= 3
            res = (n * res) % (1e9 + 7)
            return int(res)
````
特别的，当n = 4时，正好答案就是1 * 4，所以不需要单独划出一种情况来说明。
